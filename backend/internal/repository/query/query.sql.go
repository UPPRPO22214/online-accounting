// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package query

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const addAccountMember = `-- name: AddAccountMember :exec
INSERT INTO account_members (account_id, user_id, role)
VALUES (?, ?, ?)
`

type AddAccountMemberParams struct {
	AccountID int32
	UserID    int32
	Role      AccountMembersRole
}

func (q *Queries) AddAccountMember(ctx context.Context, arg AddAccountMemberParams) error {
	_, err := q.db.ExecContext(ctx, addAccountMember, arg.AccountID, arg.UserID, arg.Role)
	return err
}

const checkUserByID = `-- name: CheckUserByID :one
SELECT COUNT(*) = 1 AS user_exists
FROM users
WHERE id = ?
`

func (q *Queries) CheckUserByID(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserByID, id)
	var user_exists bool
	err := row.Scan(&user_exists)
	return user_exists, err
}

const createAccount = `-- name: CreateAccount :execresult
INSERT INTO accounts (name, description, owner_id)
VALUES (?, ?, ?)
`

type CreateAccountParams struct {
	Name        string
	Description sql.NullString
	OwnerID     int32
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createAccount, arg.Name, arg.Description, arg.OwnerID)
}

const createTransaction = `-- name: CreateTransaction :execresult
INSERT INTO transactions (
    account_id,
    user_id,
    title,
    amount,
    occurred_at,
    category,
    is_periodic
)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateTransactionParams struct {
	AccountID  int32
	UserID     int32
	Title      string
	Amount     string
	OccurredAt time.Time
	Category   sql.NullString
	IsPeriodic bool
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTransaction,
		arg.AccountID,
		arg.UserID,
		arg.Title,
		arg.Amount,
		arg.OccurredAt,
		arg.Category,
		arg.IsPeriodic,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (email, password_hash)
VALUES (?, ?)
`

type CreateUserParams struct {
	Email        string
	PasswordHash string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser, arg.Email, arg.PasswordHash)
}

const deleteAccountByID = `-- name: DeleteAccountByID :exec
DELETE FROM accounts
WHERE id = ?
`

func (q *Queries) DeleteAccountByID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteAccountByID, id)
	return err
}

const deleteTransactionByID = `-- name: DeleteTransactionByID :exec
DELETE FROM transactions
WHERE id = ?
`

func (q *Queries) DeleteTransactionByID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionByID, id)
	return err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, name, description, owner_id
FROM accounts
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetAccountByID(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountByID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.OwnerID,
	)
	return i, err
}

const getAccountMemberRole = `-- name: GetAccountMemberRole :one
SELECT role
FROM account_members
WHERE account_id = ? AND user_id = ?
LIMIT 1
`

type GetAccountMemberRoleParams struct {
	AccountID int32
	UserID    int32
}

func (q *Queries) GetAccountMemberRole(ctx context.Context, arg GetAccountMemberRoleParams) (AccountMembersRole, error) {
	row := q.db.QueryRowContext(ctx, getAccountMemberRole, arg.AccountID, arg.UserID)
	var role AccountMembersRole
	err := row.Scan(&role)
	return role, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, account_id, user_id, title, amount, occurred_at, category, is_periodic
FROM transactions
WHERE id = ?
`

func (q *Queries) GetTransactionByID(ctx context.Context, id int32) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.UserID,
		&i.Title,
		&i.Amount,
		&i.OccurredAt,
		&i.Category,
		&i.IsPeriodic,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash
FROM users
WHERE email = ?
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email
FROM users
WHERE id = ?
LIMIT 1
`

type GetUserByIDRow struct {
	ID    int32
	Email string
}

func (q *Queries) GetUserByID(ctx context.Context, id int32) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(&i.ID, &i.Email)
	return i, err
}

const listAccountMembers = `-- name: ListAccountMembers :many
SELECT user_id, role
FROM account_members
WHERE account_id = ?
`

type ListAccountMembersRow struct {
	UserID int32
	Role   AccountMembersRole
}

func (q *Queries) ListAccountMembers(ctx context.Context, accountID int32) ([]ListAccountMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountMembers, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountMembersRow
	for rows.Next() {
		var i ListAccountMembersRow
		if err := rows.Scan(&i.UserID, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, account_id, user_id, title, amount, occurred_at, category, is_periodic
FROM transactions
WHERE account_id = ?

  AND (? IS NULL OR occurred_at >= ?)
  AND (? IS NULL OR occurred_at <= ?)

  AND (? IS NULL OR is_periodic = ?)

  AND (
        ? IS NULL
        OR (? = 'income' AND amount > 0)
        OR (? = 'expense' AND amount < 0)
      )

  AND (? IS NULL OR category IN (/*SLICE:categories*/?))

ORDER BY occurred_at DESC
`

type ListTransactionsParams struct {
	AccountID    int32
	Column2      interface{}
	OccurredAt   time.Time
	Column4      interface{}
	OccurredAt_2 time.Time
	Column6      interface{}
	IsPeriodic   bool
	Column8      interface{}
	Column9      interface{}
	Column10     interface{}
	Column11     interface{}
	Categories   []sql.NullString
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	query := listTransactions
	var queryParams []interface{}
	queryParams = append(queryParams, arg.AccountID)
	queryParams = append(queryParams, arg.Column2)
	queryParams = append(queryParams, arg.OccurredAt)
	queryParams = append(queryParams, arg.Column4)
	queryParams = append(queryParams, arg.OccurredAt_2)
	queryParams = append(queryParams, arg.Column6)
	queryParams = append(queryParams, arg.IsPeriodic)
	queryParams = append(queryParams, arg.Column8)
	queryParams = append(queryParams, arg.Column9)
	queryParams = append(queryParams, arg.Column10)
	queryParams = append(queryParams, arg.Column11)
	if len(arg.Categories) > 0 {
		for _, v := range arg.Categories {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:categories*/?", strings.Repeat(",?", len(arg.Categories))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:categories*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.UserID,
			&i.Title,
			&i.Amount,
			&i.OccurredAt,
			&i.Category,
			&i.IsPeriodic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAccounts = `-- name: ListUserAccounts :many
SELECT
    a.id,
    a.name,
    a.description,
    am.role
FROM account_members am
JOIN accounts a ON a.id = am.account_id
WHERE am.user_id = ?
ORDER BY a.id
`

type ListUserAccountsRow struct {
	ID          int32
	Name        string
	Description sql.NullString
	Role        AccountMembersRole
}

func (q *Queries) ListUserAccounts(ctx context.Context, userID int32) ([]ListUserAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserAccountsRow
	for rows.Next() {
		var i ListUserAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAccountMember = `-- name: RemoveAccountMember :exec
DELETE FROM account_members
WHERE account_id = ? AND user_id = ?
`

type RemoveAccountMemberParams struct {
	AccountID int32
	UserID    int32
}

func (q *Queries) RemoveAccountMember(ctx context.Context, arg RemoveAccountMemberParams) error {
	_, err := q.db.ExecContext(ctx, removeAccountMember, arg.AccountID, arg.UserID)
	return err
}

const updateAccountMemberRole = `-- name: UpdateAccountMemberRole :exec
UPDATE account_members
SET role = ?
WHERE account_id = ? AND user_id = ?
`

type UpdateAccountMemberRoleParams struct {
	Role      AccountMembersRole
	AccountID int32
	UserID    int32
}

func (q *Queries) UpdateAccountMemberRole(ctx context.Context, arg UpdateAccountMemberRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateAccountMemberRole, arg.Role, arg.AccountID, arg.UserID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :execresult
UPDATE users
SET password_hash = ?
WHERE id = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash string
	ID           int32
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
}
